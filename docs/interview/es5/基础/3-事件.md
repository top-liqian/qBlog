# eventLoop相关的面试题

## 1. 什么是eventloop（事件循环）

js是单线程运行的，当遇到异步事件会将这个事件放在事件队列当中，继续执行执行栈中的其他任务。当前执行栈中的所有任务都执行完主线程处于闲置状态时，主线程会去查找事件队列是否有任务，主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码...，如此反复就被称为事件循环（Event Loop）。

异步任务分两类：微任务（micro task）和宏任务（macro task）。

微任务包括： promise 的回调、node 中的 process.nextTick 、对 Dom 变化监听的 MutationObserver。

宏任务包括： script 脚本的执行，setTimeout 、setInterval 和setImmediate 一类的定时事件，还有如 I/O 操作，UI 渲染等。

## 2. 宏任务和微任务的优先级?

在微任务优先级高于宏任务

## 3. 采用单线程模式工作的原因？

js使用单线程主要是为了避免复杂的线程同步问题，如果在javaScript线程当中有多个任务需要执行，其中一个线程修改了某一个dom元素，另外一个线程又删除了某一个Dom元素，那此时浏览器就不知道该以那一次的线程结果为准，这样设计的优点：安全简单，缺点：遇到耗时的任务就会导致假死的情况

## 4. JS 中异步任务为什么分为微任务与宏任务

主要是为了微任务当中注册的微任务可以插队，如果不区分任务类型，新注册的任务就要等下一个宏任务执行完毕之后在执行，中间需要的状态就没办法在下一个任务中同步

## 5. 请用一句话描述 try catch 能捕获到哪些 JS 异常?

线程执行已经进入```try catch``` 但 ```try catch``` 未执行完的时候抛出来的。

```Promise``` 没有异常！事实上，Promise 的异常都是由``` reject ```和``` Promise.prototype.catch``` 来捕获，不管是同步还是异步。**核心原因**是因为 Promise 在执行回调中都用` try catch `包裹起来了，其中所有的异常都被内部捕获到了，并未往上抛异常。

## 6. 为什么 setTimeout 有最小时延 4ms ?

在chrome浏览器在设计的时候源代码当中设置了kMaxTimerNestingLevel 和 kMinimumInterval 两个变量分别为 5 和 4， 分别表示最大的嵌套层数和最小的毫秒数

## 7.如何实现一个 0ms 的 setTimeout?

```js
let timeouts = []; // 1. 首先定义一个数组存放timeout的事件
const messageName = 'zero-settimeout' // 2. 定义postmessage的字段
function setTimeoutZero(fn) { // 3. 定义postMessage的信息并且存储timeout事件
  timeouts.push(fn);
  window.postMessage(messageName, '*')
}
function handleMessage (evt) { // 5. 回调函数内部执行timeout的fn
  if (evt.source == window && evt.data === messageName) {
    if (timeouts.length > 0) {
      const f = timeouts.shift()
      f()
    }
  }
}
window.addEventListener('message', handleMessage) // 4. 监听messageName的事件，定义回调函数
window.zeroSettimeout = setTimeoutZero;
```

## 8. 事件循环通常会考察输出结果，类型分为以下几种

1. 考察同步任务 + 异步任务 + async + promise => 解题思路：遇到async/await的代码，现将其改写成 new Promise的形式

```js
  async function async1() {
    console.log('async1 start');
    await async2();
    console.log('async1 end');
  }
  const async2 = async () => console.log('async2')
  console.log('script start');
  setTimeout(() => console.log('setTimeout'), 0)
  async1();
  new Promise(function (resolve) {
    console.log('promise1');
    resolve();
    console.log('promise2')
  }).then(function () {
    console.log('promise3');
  });
  console.log('script end');
```
答案： script start、async1 start、async2、promise1、promise2、script end、async1 end、promise3、setTimeout

2. promise具有多回调的情况 => 解题思路在于：第一轮微任务结束之后会执行第二轮微任务，最后才是宏任务

```js
setTimeout(() => console.log(0));
new Promise((resolve) => {
  console.log(1);
  resolve(2);
  console.log(3);
}).then((o) => console.log(o));

new Promise((resolve) => {
  console.log(4);
  resolve(5)
})
  .then((o) => console.log(o))
  .then(() => console.log(6));
```
答案：1 3 4 2 5 6 0 
              
```js
Promise.resolve(console.log(0))
  .then(() => {
    console.log(1);
    Promise.resolve(console.log(5))
      .then(() => console.log(3))
      .then(() => console.log(4))
      .then(() => console.log(6));
  })
  .then(() => console.log(2))
  .then(() => console.log(7));

// 0 1 5 3 2 4 7 6 

setTimeout(() => console.log(0))
new Promise((resolve) => {
  console.log(1)
  resolve(2)
  console.log(3)
}).then(o => console.log(o))

new Promise(resolve => {
  console.log(4)
  resolve(5)
}).then(o => console.log(o)).then(() => console.log(6))
// 答案：1 3 4 2 5 6 0
```
3. setTimeout内部包含promise => 解题思路：第一轮微任务结束之后会执行第二轮微任务，最后才是宏任务

```js
setTimeout(() => {
  console.log("A");
  Promise.resolve().then(() => console.log("B"));
}, 1000);

Promise.resolve().then(() => console.log("C"));
new Promise((resolve) => {
  console.log("D");
  resolve("");
}).then(() => {
  console.log("E");
});
async function sum(a, b) { console.log("F") }
async function asyncSum(a, b) {
  await Promise.resolve();
  console.log("G");
  return Promise.resolve(a + b);
}
sum(3, 4);
asyncSum(3, 4);
console.log("H");
```
答案：D F H C E G A B

## 9. 请说出下面的执行时机
```js
function wait() {
  return new Promise(resolve =>
    setTimeout(resolve, 10 * 1000)
  )
}

async function main() {
  console.time();
  const x = wait();
  const y = wait();
  const z = wait();
  await x;
  await y;
  await z;
  console.timeEnd();
}
main();
```

new Promise(xx)相当于同步任务, 会立即执行

所以: x,y,z 三个任务是几乎同时开始的, 最后的时间依然是10*1000ms (比这稍微大一点点, 超出部分在1x1000ms之内)