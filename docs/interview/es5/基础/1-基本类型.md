# 基础类型面试题

## 1. js的数据类型

JavaScript共有八种数据类型，分别是 Boolean、Number、String、Undefined、Null、Object、Symbol、BigInt。

> 衍生问题：js 中的基础类型和对象类型有什么不一样？
>
> 基础类型存储在栈中，对象类型存储在堆中。

## 2. symbol 有什么用处

可以模拟私有变量、作为对象独一无二的key，可以保证不会与其他属性名产生冲突

## 2. 原始类型和引用类型的存储方式？

+ 原始数据类型直接存储在栈（stack），占据空间小、大小固定，由编译器自动分配释放

+ 引用数据类型存储在堆（heap），占据空间大、大小不固定。由开发着分配释放，若开发者不释放，程序结束时可能由垃圾回收机制回收

## 3. 什么是 JavaScript 中的包装类型？

在调用基本类型的属性或方法时 JavaScript 会在后台隐式地将基本类型的值转换为包装类型的对象，var的过程相当于new的过程，也可以使用valueOf方法将包装类型倒转成基本类型

## 4. 字符串是基本数据类型,基本类型是没有方法的，但为什么字符串还有很多方法

因为创建字符串的过程实际上是创建String类的过程，在String类上具有很多方法，所以字符串会继承自String

## 5. 给出下面题目的正确答案

```js
var str = 'string'; str.pro = 'hello'; console.log(str.pro + 'world');
```

undefindedworld；tr.pro在赋值的时候实际上内部创建了一个基本包装类型的实例，实例创建后马上销毁了，console的时候尝试获取 str.pro 的值时，又会创建一个新的基本包装类型的实例，这个新的实力上并没有 pro 属性的所以是 undefined

## 6. null和undefined

null：表示空对象，用于赋值给一些可能会返回对象的变量，作为初始化

undefined: 表示为定义，一般变量声明了但还没有定义的时候会返回 undefined

```js
null === undefined => false null == undefined => true
```
  
## 8. 为什么会有BigInt的提案？

为了解决js超出最⼤安全数字这个范围就会出现精度丢失计算不准确的情况

## 9. 如何获取安全的undefined

可以用 void 0 来获得 undefined

## 10. NaN 是什么，用 typeof 会输出什么？

Not a Number，表示非数字，typeof NaN === 'number'

## 12.es6中的声明

声明方式：`var` `let` `const` `class` `function` `import`

## 13. 数据类型检测的方式有哪些？

typeof、instanceof、constructor、Object.prototype.toString.call

1. typeof：其中数组、对象、null都会被判断为object，其他判断都正确
2. instanceof： instanceof只能正确判断引用数据类型，而不能判断基本数据类型，其内部运行机制是判断在其原型链中能否找到该类型的原型，instanceof 运算符可以用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性
3. constructor：constructor有两个作用，一是判断数据的类型，二是对象实例通过 constrcutor 对象访问它的构造函数。需要注意，如果创建一个对象来改变它的原型，constructor就不能用来判断数据类型了
4. Object.prototype.toString.call()：使用 Object 对象的原型方法 toString 来判断数据类型

## 14. Obj.toString()的结果和Object.prototype.toString.call(obj)的结果不一样，这是为什么？

obj.toString()只能将obj转换为字符串类型，Object原型上的toString方法是得到对象的具体类型，所以结果不一样

这是因为toString是Object的原型方法，Object的实例可能**重写了toString方法**。不同的对象类型调用toString方法时调用的是对应的重写之后的toString方法，而不会去调用Object上原型toString方法（返回对象的具体类型），所以采用obj.toString()不能得到其对象类型，只能将obj转换为字符串类型

## 15.  isNaN 和 Number.isNaN 函数的区别？

+ 函数 isNaN 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 true，因此非数字值传入也会返回 true ，会影响 NaN 的判断。
+ 函数 Number.isNaN 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，不会进行数据类型的转换，这种方法对于 NaN 的判断更为准确。

## 16. 什么是安全整数，如何判断一个整数是安全整数

一个安全整数是一个符合下面条件的整数：

可以准确地表示为一个 IEEE-754 双精度数字,其 IEEE-754 表示不能是舍入任何其他整数以适应 IEEE-754 表示的结果。

```js
Number.MAX_SAFE_INTEGER 是最大安全整数，Number.isSafeInteger() 用来判断一个数值是否为安全整数。
```

## 17. 如何判断一个数值为整数

```js
// ES6
Number.isInteger(num);

// ES5
if (!Number.isInteger) {
  Number.isInteger = function (num) {
    return typeof num == "number" && num % 1 == 0;
  };
}
```

## 18. 实现二进制与十进制的互相转化的两个函数

```js
function integerToBin(num) {
  // 64
  const result = [];
  while (num / 2) {
    next = num % 2;
    num = Math.floor(num / 2);
    result.unshift(next);
  }
  return result;
}

function fractionalToBin(num) {
  const result = [];
  let i = 0;
  while (num !== 0 && i < 54) {
    num = num * 2;

    next = num >= 1 ? 1 : 0;
    num = num % 1;
    i++;
    result.push(next);
  }
  return result;
}

function decToBinary(num) {
  // 1.5
  const [int, fraction] = String(num)
    .split(/(?=\.)/)
    .map((x, i) => {
      return i === 0 ? integerToBin(x) : fractionalToBin(x);
    });
  return [int, fraction];
}

function binToDec(num) {
  const [_int, _fraction] = String(num).split(".");
  const int = _int.split("").reduceRight((acc, x, i) => {
    return acc + x * 2 ** i;
  }, 0);
  const fraction = _fraction
    ? _fraction.split("").reduce((acc, x, i) => {
        return acc + x * 2 ** -(i + 1);
      }, 0)
    : 0;
  return `${int}${fraction ? "." + fraction.toString().slice(2) : ""}`;
}

console.log(16, integerToBin(16), Number(16).toString(2));
console.log(18, integerToBin(18), Number(18).toString(2));
console.log(0.5, fractionalToBin(0.5), Number(0.5).toString(2));
console.log(0.1, fractionalToBin(0.1), Number(0.1).toString(2));
console.log(1.1, decToBinary(1.1), Number(1.1).toString(2));

console.log(7.875, decToBinary(7.875), Number(7.875).toString(2));
console.log("111.111", binToDec("111.111"), parseInt("111.111", 2));
```

## 20. 0.1 + 0.2 为什么不等于 0.3

计算机中所有的数据都是以```二进制```存储的，所以在计算时计算机要把数据先转换成```二进制```进行计算，然后在把计算结果转换成```十进制```，所以计算机计算0.1+0.2的时候，实际上是计算的两个数的二进制的和。0.1的二进制是0.0001100110011001100...（1100循环），0.2的二进制是：0.00110011001100...（1100循环），这两个数的二进制都是无限循环的数，IEEE 754 标准中的尾数位只能保存 52 位 有效数字，所以 0.1和0.2转二进制就会发生舍入，所以就产生了误差，所以就不等于0.3

## 21.怎么样判断 0.1+0.2 = 0.3

设置一个误差范围，在ES6中，提供了Number.EPSILON属性，而它的值就是2-52，只要判断0.1+0.2-0.3是否小于Number.EPSILON，如果小于，就可以判断为0.1+0.2 === 0.3

```js
function numberepsilon(arg1,arg2){                   
  return Math.abs(arg1 - arg2) < Number.EPSILON;        
}        

console.log(numberepsilon(0.1 + 0.2, 0.3)); // true
```

## 22. 怎么能使 0.1 + 0.2 = 0.3

1. 转为整数计算，计算后再转回小数
2. 转成字符串相加（效率较低）

## 23.JavaScript是如何处理无限循环的二进制小数？

遵从“0舍1入”的原则

## 24. js对二进制小数的存储方式?

ECMAScript中的Number类型遵循```IEEE 754标准```,使用```64位```固定长度来表示，共有符号位（1）、指数位（11）、尾数位（52）三部分组成

## 25. Number() 的存储空间是多大？如果后台发送了一个超过最大自己的数字怎么办

Math.pow(2, 53) ，53 为有效数字，会发生截断，等于 JS 能支持的最大数字。

## 26. 二进制小数的存储为什么尾数位只有 52 位，但是要从第一个 1 后面开始保留52位 有效数字？

尾数部分的整数部分一定是一个 1,那为了充分利用 52 位 空间**表示更高的精确度**，可以把一定等于 1 的整数部分省略，52 位 都用来表示小数。

## 27. 其他值到字符串的转换规则？即toString类型

1. null -> 'null', undefined -> 'undefined'
2. true -> 'true', false -> 'false'
3. Number直接转换 1 -> '1', 不过那些极小和极大的数字会使用指数形式
4. Symbol 类型的值直接转换，但是只允许显式强制类型转换，使用隐式强制类型转换会产生错误。
5. 对普通对象来说，除非自行定义 `toString()` 方法，否则会调用 `toString()（Object.prototype.toString()）`来返回内部属性 `[[Class]] `的值，如`"[object Object]"`。如果对象有自己的 `toString()` 方法，字符串化时就会调用该方法并使用其返回值

## 28. 其他值到数字值的转换规则？即toNumber类型

1. undefined -> NaN
2. null -> 0
3. true -> 1, false -> 0
4. String 类型的值转换如同使用 Number() 函数进行转换，如果包含非数字值则转换为 NaN，空字符串为 0
5. Symbol 类型的值不能转换为数字，会报错
6. 对象（包括数组）会首先被转换为相应的基本类型值，如果返回的是非数字的基本类型值，则再遵循以上规则将其强制转换为数字

> 为了将值转换为相应的基本类型值，抽象操作 ToPrimitive 会首先（通过内部操作 DefaultValue）检查该值是否有valueOf()方法。如果有并且返回基本类型值，就使用该值进行强制类型转换。如果没有就使用 toString() 的返回值（如果存在）来进行强制类型转换。
> 
> 如果 valueOf() 和 toString() 均不返回基本类型值，会产生 TypeError 错误。

## 29.其他值到布尔类型的值的转换规则？ 即toBoolean类型

以下这些是假值： `• undefined • null • false • +0、-0 和 NaN • ""`

假值的布尔强制类型转换结果为 false。从逻辑上说，假值列表以外的都应该是真值。

## 30.介绍一下JavaScript的ToPrimitive

JavaScript 中每个值隐含的自带的方法 `ToPrimitive`, 用来将值 （无论是基本类型值还是对象）转换为基本类型值, 如果值为基本类型，则直接返回值本身；如果值为对象，其看起来大概是这样：

```js
/**
* @obj 需要转换的对象
* @type 期望的结果类型
*/
ToPrimitive(obj,type)
```
type的值为number或者string

1. 当type为number时规则：调用obj的valueOf方法，如果为原始值，则返回，否则调用obj的toString方法 如果不行抛出TypeError 异常。
  
2. 当type为string时规则：调用obj的toString方法，如果为原始值，则返回，否则调用obj的valueOf方法，否则抛出TypeError 异常。

**如果对象为 Date 对象，则type默认为string，其他情况下，type默认为number**

对于 Date 以外的对象，转换为基本类型的大概规则可以概括为一个函数：`Number(value.valueOf().toString())`

## 31.JavaScript中如何进行隐式类型转换？

JavaScript 中的隐式类型转换主要发生在`+、-、*、/以及==、>、<`这些运算符之间, 而这些运算符只能操作基本类型值，所以在进行这些运算前的第一步就是将两边的值用ToPrimitive转换成基本类型，再进行操作。

1. `+操作符`: `+操作符`的两边有至少一个`string`类型变量时，两边的变量都会被隐式转换为`字符串`；其他情况下两边的变量都会被转换为`数字`, 注意 **1+Symbol() 会报错**
2. `-、*、\`操作符：1 / 'aa' => NaN
3. 对于`==`操作符：操作符两边的值都尽量转成number
4. 对于`<`和`>`比较符： 如果两边都是字符串，则比较字母表顺序，其他情况下，转换为数字再比较

对象会被ToPrimitive转换为基本类型再进行转换：

```js
var a = {name:'Jack'}
var b = {age: 18}
a + b // "[object Object][object Object]"

a.valueOf() // {}，上面提到过，ToPrimitive默认type为number，所以先valueOf，结果还是个对象，下一步
a.toString() // "[object Object]"
b.valueOf() // 同理
b.toString() // "[object Object]"
a + b // "[object Object][object Object]"
```

## 32. + 操作符什么时候用于字符串的拼接？

如果 + 的其中一个操作数是字符串（或者通过以上步骤最终得到字符串），则执行字符串拼接，否则执行数字加法。

那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字

## 33. 将字符串转换为数字的方法

+号是将字符串转换为数字的最快方法，因为如果值已经是数字，它不会执行任何操作

## 34. 函数的参数的传递规则？

参数如果是原始类型就是按值传递的，当函数参数是引用类型时，我们同样将参数复制了一个副本到局部变量，只不过复制的这个副本是指向堆内存中的地址而已，我们在函数内部对对象的属性进行操作，实际上和外部变量指向堆内存中的值相同，但是这并不代表着引用传递


## 35. 列举 Number、String、Array、Object、Promise 有哪些 API

### Number
+ Number.isNaN()
+ Number.isInteger()
+ Number.isInfinite()
+ Number.isSafeInteger()
+ Number.prototype.toFixed()
  
### String
+ String.fromCharCode()
+ String.raw()
+ String.prototype.charAt()
+ String.prototype.charCodeAt()
+ String.prototype.concat()
+ String.prototype.startsWith()
+ String.prototype.endsWith()
+ String.prototype.includes()
+ String.prototype.indexOf()
+ String.prototype.lastIndexOf()
+ String.prototype.charAt()
+ String.prototype.charCodeAt()
+ String.prototype.trim()
+ String.prototype.trimStart()
+ String.prototype.trimEnd()
+ String.prototype.repeat()
+ String.prototype.replace()
+ String.prototype.slice()
+ String.prototype.split()
+ String.prototype.sub+ String()
+ String.prototype.padStart()
+ String.prototype.padEnd()
+ String.prototype.search()
+ String.prototype.match()
+ String.prototype.toLowerCase()
+ String.prototype.toUpperCase()
### Array
+ Array.isArray()
+ Array.from()
+ Array.of()
+ Array.prototype.slice()
+ Array.prototype.splice()
+ Array.prototype.sort()
+ Array.prototype.reverse()
+ Array.prototype.indexOf
+ Array.prototype.lastIndexOf()
+ Array.prototype.includes()
+ Array.prototype.push()
+ Array.prototype.pop()
+ Array.prototype.shift()
+ Array.prototype.unshift()
+ Array.prototype.map()
+ Array.prototype.reduce()
+ Array.prototype.forEach()
+ Array.prototype.filter()
+ Array.prototype.every()
+ Array.prototype.some()
+ Array.prototype.flat()
+ Array.prototype.flatMap()
+ Array.prototype.toString()
### Object
+ Object.create()
+ Object.assign()
+ Object.defineProperties()
+ Object.defineProperty()
+ Object.keys()
+ Object.values()
+ Object.entries()
+ Object.fromEntries()
+ Object.is()

# 操作符相关面试题

## 1. typeof和instanceof的区别

1. typeof 会返回一个运算数的基本类型，instanceof 返回的是布尔值

2. instanceof 可以准确判断引用数据类型，但是不能正确判断原始数据类型

3. typeof 虽然可以判断原始数据类型（null 除外），但是无法判断引用数据类型（function 除外）

## 2. typeof为什么检测null的时候会是object？

因为js在开发初期为了性能而使用低位1-3位存储变量的类型信息，约定000开头为对象，而null的二进制刚好设置为全0，因此直接被当做了对象来看待，这是一个历史问题bug

## 3. typeof document.all === undefined

在 V8 中，每一个 Javascript 对象都有一个与之关联的 Map 对象，Map 对象描述 Javascript 对象类型相关的信息，类似元数据
Map 对象主要使用 16 bit 的 instance_type 字段来描述对应 Javascript 对象的类型

undefined 的 is_undetectable bit 是 1

document.all 的 is_undetectable 也是 1

所以才会有 typeof document.all 等于 undefined 的不合理情况

## 4. typeof 1/0 等于什么和为什么？

由于`typeof`运算符优先级高于除法，所以会先执行`typeof 1`, 返回`'number'`。然后执行 '`number' / 0`的操作。此时会隐式调用`Number`转型函数将`'number'`转换成`NaN`。最后执行`NaN / 0`的操作。此时会返回`NaN`  所以结果是`NaN`
。

## 5. NaN 是什么，用 typeof 会输出什么？

NaN 指“不是一个数字”（not a number），NaN 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。

typeof NaN; => "number"

NaN 是一个特殊值，它和自身不相等，是唯一一个非自反（自反，reflexive，即 x === x 不成立）的值。而 NaN !== NaN 为 true。

## 6. new 一个函数发生了什么？

1. 创建一个新的对象`F`
2. 这个新对象的`__proto__`属性指向构造函数的`prototype`,即`F.__proto__ = Fun.prototype`
3. 执行构造函数`Fun`，使用指定的参数调用构造函数`Fun`，并将 this 绑定到新创建的对象
4. 构造函数如果有返回值，如果返回`原始值`即没有返回对象类型Object(包含Functoin, Array, Date, RegExg, Error)（例如 return 1） 那么这个返回值将`没有`任何意义，还是会返回`F`
5. 构造函数如果返回一个`对象`，那么这个对象就会被正常`引用`，返回其他对象会导致获取不到构造函数的实例，很容易因此引起意外的问题！
6. 返回的对象将作为构造函数的实例

## 7. new 一个构造函数，如果函数返回 return {} 、 return null ， return 1 ， return true 会发生什么情况？

如果函数返回一个对象，那么new 这个函数调用返回这个函数的返回对象，否则返回 new 创建的新对象

## 8. typeof null 的结果是什么，为什么？

typeof null 的结果是Object。

在 JavaScript 第一个版本中，所有值都存储在 32 位的单元中，每个单元包含一个小的 类型标签(1-3 bits) 以及当前要存储值的真实数据

undefined的机器码值是 (-2)30(一个超出整数范围的数字), null 的值是机器码 NULL 指针(null 指针的值全是 0)

null的类型标签也是000，和Object的类型标签一样，所以会被判定为Object

## 9. && 运算符能做什么

逻辑与， 采用短路来防止不必要的工作，在其操作数中找到第一个虚值表达式并返回它，如果没有找到任何虚值表达式，则返回最后一个真值表达式

## 10. || 运算符能做什么

逻辑或，在其操作数中找到第一个真值表达式并返回它。这也使用了短路来防止不必要的工作。在支持 ES6 默认函数参数之前，它用于初始化函数中的默认参数值。

## 11. Object.is() 与比较操作符 “===”、“==” 的区别？

+ 使用双等号（==）进行相等判断时，如果两边的类型不一致，则会进行强制类型转化后再进行比较。
+ 使用三等号（===）进行相等判断时，如果两边的类型不一致时，不会做强制类型准换，直接返回 false。
+ 使用 Object.is 来进行相等判断时，一般情况下和三等号的判断相同，它处理了一些特殊的情况，比如 -0 和 +0 不再相等，两个 NaN 是相等的

## 12. object.assign和扩展运算法是深拷贝还是浅拷贝，两者区别

两者都是浅拷贝

+ Object.assign()方法接收的第一个参数作为目标对象，后面的所有参数作为源对象。然后把所有的源对象合并到目标对象中。它会修改了一个对象，因此会触发 ES6 setter。
+ 扩展操作符（…）使用它时，数组或对象中的每一个值都会被拷贝到一个新的数组或对象中。它不复制继承的属性或类的属性，但是它会复制ES6的 symbols 属性。