# 一、闭包相关的面试题

## 1. 什么是闭包

闭包就是每次调用外层函数时，临时创建的函数作用域对象。因为内层函数作用域链中包含外层函数的作用域对象，内层函数被引用，导致内层函数不会被释放，同时它又具有对父级作用域的引用，这个时候就形成了闭包，所以闭包通常是在函数嵌套中形成的。

闭包的作用域链包含了自身作用域，被定义所在函数作用域以及全局作用域

**闭包的本质（原理）可答可不答**：在JavaScript中，作用域对象是在堆中被创建的（至少表现出来的行为是这样的），函数在执行的时候会放到一个执行栈上当函数执行完毕之后就从执行栈上移除，但是堆上作用域成员因为被外部引用而不能被释放，因此内部函数依然可以访问外部函数的成员
 
## 2. 怎样产生一个闭包

在一个函数内部定义另一个函数

## 3. 闭包的注意事项

1. 产生了闭包的函数作用域会一直存在等闭包不存在了之后才会被销毁
2. 闭包只能取回包含函数中任何变量的最后一个值
3. 如果内层函数返回的是一个是匿名函数，匿名函数的作用域指向了全局window，**匿名函数的执行函数具有全局性**

## 4. 闭包的应用

定义函数的私有变量、可以做计数器、实现块级作用域、函数柯里化
   
## 5. 闭包的优点

缓存变量将变量隐藏起来不被GC回收
   
## 6. 闭包的缺点

内存消耗，闭包产生的变量无法被销毁；性能问题，由于闭包内部变量优先级高于外部变量，所以需要多查找作用域链的一个层次，一定程度影响查找速度

## 7. 什么是函数柯里化Currying

柯里化是把接受多个参数的函数转变为单一参数的函数，返回接受余下的参数且返回结果的新函数的技术。主要是通过闭包管理，支持链式调用且每次运行返回一个function

## 8. 柯里化有什么好处？

参数复用、提前确认、延迟运行

## 9. 实现 add(1)(2)(3)

```js
// 实现一个 add 方法，使计算结果能够满足以下预期
add(1)(2)(3) = 6;
add(1, 2, 3)(4) = 10;
add(1)(2)(3)(4)(5) = 15;

function add () {
  const numberList = Array.from(arguments);
  const calculate = function() { // 进一步收集剩余参数
    numberList.push(...arguments);
    return calculate;
  }
  // 利用 toString 隐式转换，最后执行时进行转换
  calculate.toString = function() {
    return numberList.reduce((a, b) => a + b, 0);
  }
  return calculate;
}
```

## 10. 实现compose(foo, bar, baz)('start')

```js
const foo = (...args) => 'foo'
const bar = (...args) => 'bar'
const baz = (...args) => 'baz'

function compose() {
  const list = Array.from(arguments); // 
  let index = -1; // 闭包元素 - 函数列表执行位置
  let prev = ''; // 闭包元素 - 上一个函数的返回
  const doNext = function() { // 返回闭包函数
    index++; // 索引值累加
    // 一开始没有上一个元素时，获取第二个括号的值
    if (!prev) prev = arguments[0] 
    prev = list[index](prev); // 设置前一个结果为当前函数返回
    if (index < list.length - 1) doNext(index + 1);
  };
  return doNext; // 第一次返回闭包函数
}
```

## 11. lodash中的柯里化函数

**_.curry(func)**

+ 功能：创建一个函数，该函数接收一个或者多个func的参数，如果func所需要的参数都被提供则执行func并返回执行的结果。否则继续返回该函数并等待接收剩余的参数
+ 参数：需要柯里化的参数
+ 返回值：柯里化之后的函数

### 柯里化案例

1. 提取字符串中的空白字符

```js
''.match(/\s+/g)

const match = reg => (str => str.match(reg))
const matchSpace = match(/\s+/g)
console.log(matchSpace('helloword')) // null
console.log(matchSpace('hello word')) // ['']
```

2. 提取数组中的空白字符

```js
const match = reg => (str => str.match(reg))
const haveSpace = match(/\s+/g)
const _filter = func => (arr => arr.filter(func))
console.log(_filter(haveSpace)(['helloword', 'hello word']))
```

### 模拟实现_.curry(func)方法

```js
function curry(func) {
return function curriedFn(...args) {
 if (args.length < func.length) {
   return function () {
     return 
      curriedFn(
        ...args.concat(Array.from(arguments))
      )
   }
 }
 return func(...args)
}
}
```

### 总结

+ 柯里化可以让我们给一个函数传递较少的参数得到一个已经记住了某些固定参数的新函数
+ 这是一种对函数参数的缓存
+ 让函数变得更灵活，让函数的粒度更小
+ 可以把多元函数转换成一元函数，可以组合使用函数产生强大的功能

## 7. 闭包相关的面试题

js闭包是如何处理父函数中let形成块级作用域中定义的变量的

> 解答：区别在于每次for循环里面都是一个单独的块极作用域，而let就是块极作用域里面声明变量，可以理解为每次执行for的时候都是一个新的i，所以在for循环的块中找，自然i不一样，可以理解为每次循环都保存了一个变量i，这个i属于对应的那次执行的块极作用域，而var是函数作用域，for循环无论执行多少次，都是去最近的堆栈里面找，而不是块中找，所以只有一个i，现在的i是10



1. 输出下面的结果

```js
function fun(n, o) {
  console.log(o)
  return {
    fun: function (m) {
      return fun(m, n)
    }
  }

}
var a = fun(0) // undefiend
a.fun(1) // 0
a.fun(2) // 0
a.fun(3) // 0
var b = fun(0).fun(1).fun(2).fun(3) // undefiend 0 1 2
var c = fun(0).fun(1) // undefiend 0
c.fun(2) // 1
c.fun(3) // 1

```

2. 输出结果

```js
function test() {
  var n = 4399;

  function add() {
    n++;
    console.log(n);
  }

  return {
    n,
    add
  };
};

var result = test();
var result2 = test();

result.add(); // 输出啥
result.add(); // 输出啥

console.log(result.n); // 输出啥

result2.add(); // 输出啥

// 4400 4401 4399 4400
```

3. 输出结果
  
```js
function Foo() {
  var i = 0;
  return function() {
    console.log(i++);
  }
}

var f1 = Foo();
var f2 = Foo();

f1();
f1();
f2();

// 0 1 0
```

4. 闭包是什么时候被销毁的？
   
当它不被任何其他的对象引用的时候。


# 二、作用域、作用域链相关的面试题

## 1. 对作用域的理解

作用域分为三种：全局、函数、块级的

+ 全局作用域：最外层函数和最外层函数外面定义的变量、所有未定义直接赋值的变量、所有window对象的属性都会产生全局作用域
+ 函数作用域：声明在函数内部的变量
+ 块级作用域：let和const指令可以声明块级作用域；在函数中创建或者由{ }包裹的代码片段

## 2. 什么是作用域链

使用一个变量时，JS引擎会尝试在当前作用域下寻找该变量，如果没找到，再到它的上层作用域寻找，以此类推，直至找到该变量或是查找至全局作用域，如果在全局作用域里仍然找不到该变量，它就会在全局范围内隐式声明该变量(非严格模式下)或是直接报错。整个查找形成的链条就是作用域链

## 3. 作用域链的作用？

保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，可以访问到外层环境的变量和函数

# 三、执行上下文相关的面试题

## 1. 执行上下文类型

1. 全局执行上下文：任何不在函数内部的都是全局执行上下文，有且只有一个，会创建一个全局的window对象，并将this指向全局对象
2. 函数执行上下文：当函数被调用时就创建一个新的执行上下文
3. eval函数执行上下文： 执行在eval函数中的代码会有属于他自己的执行上下文

## 2. 执行上下文的生命周期

创建阶段 → 执行阶段 → 回收阶段

## 3. 什么是执行上下文栈？

程序执行默认进入全局执行上下文中，此时如果在全局环境中调用了一个函数, 就会为整个函数创建一个函数执行上下文并且将这个上下文压入执行栈之中。只要有新的执行上下文，它被压入现有栈的顶部。浏览器永远会执行当前栈中顶部的执行上下文

## 4. 如何创建执行上下文？

首先会创建一个window对象，并将this进行绑定，如果是在全局执行上下文中，this指向window，如果是函数执行上下文，那么this的指向取决于函数如何调用，如果是被一个引用对象调用那么this就指向整个引用对象，否则就指向window/undefined；然后创建词法环境，用来存储变量/函数与实际对象或者原始数据的映射，然后创建变量环境，将持有变量声明语句在执行上下文中创建的绑定关系，最后完成对变量的分配，然后执行代码

## 5. JS预解析？

预解析分为变量预解析和函数预解析，这两种预解析都是将当前的声明提升至作用域的最前面，只提升声明，不提升赋值/调用；函数表达式的写法不存在函数提升；函数提升优先级高于变量提升，且不会被同名变量声明时覆盖，但是会被同名变量赋值后覆盖
