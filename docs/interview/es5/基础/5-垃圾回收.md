# 垃圾回收

## 1. 为什么要有垃圾回收？

使用JavaScript语言，V8引擎会根据你当前定义对象的大小去自动申请分配内存，不需要我们去手动管理内存了，所以就有垃圾回收。垃圾回收的好处是不需要我们去管理内存，把更多的精力放在实现复杂应用上，但坏处也来自于此，不用管理了，就有可能在写代码的时候不注意，造成循环引用等情况，导致内存泄露。

## 2. 内存结构分配

V8可以申请的最大内存在64位系统下大约为1.4GB，在32位系统下大约为700MB。

## 3. v8 中的垃圾回收机制分为三种

+ Scavenge，工作在新生代，把 from space 中的存活对象移至 to space
+ Mark-Sweep，标记清除。新生代的某些对象由于过度活跃会被移至老生代，此时对老生代中活对象进行标记，并清理死对象
+ Mark-Compact，标记整理。

## 4. WeakMap 与垃圾回收有何关系

WeakSet 不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。WeakSet 的一个用处是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏。

## 5. 哪些情况会导致内存泄漏（6种）

1. 全局变量。在局部作用域中，函数执行完毕后，变量就没有存在的必要了，垃圾回收机制很快的做出判断并回收；但是对于全局变量，很难判断什么时候不用这些变量，无法正常回收。
解决办法：
① 尽量少使用全局变量；
② 使用严格模式，在 js 文件头部或者函数的顶部加上use strict。

2. 闭包引起的内存泄露。闭包可以读取函数内部的变量，然后让这些变量始终保存在内存中，如果在使用结束后没有将局部变量清除，就可能导致内存泄露。
解决办法：将事件处理函数定义在外部，解除闭包。

3. 定时器setInterval或者setTimeout不再需要使用时，且没有被清除，导致定时器的回调函数及其内部依赖的变量都不能被回收，就会造成内存泄漏。
解决办法：当不需要定时器的时候，调用clearInterval或者clearTimeout手动清除。

4. 事件监听。垃圾回收机制不好判断事件是否需要被解除，导致callback不能被释放，此时需要手动解除绑定。
解决办法：及时使用removeEventListener移除事件监听。

5. 元素引用没有清理。
解决办法：移除元素后，手动设置元素的引用为null。

6. console。传递给console.log的对象是不能被垃圾回收，可能会存在内存泄漏。
解决办法：清除不必要的console。

## 6. 如何减少垃圾回收

+ 对数组进行优化：在清空一个数组时，最简单的方法就是给其赋值为[ ]，但是与此同时会创建一个新的空对象，可以将数组的长度设置为0，以此来达到清空数组的目的。
+ 对object进行优化：对象尽量复用，对于不再使用的对象，就将其设置为null，尽快被回收。
+ 对函数进行优化：在循环中的函数表达式，如果可以复用，尽量放在函数的外面。

## 7. 垃圾回收机制

+ Javascript 具有自动垃圾回收机制，会定期对那些不再使用的变量、对象所占用的内存进行释放，原理就是找到不再使用的变量，然后释放掉其占用的内存。
+ JavaScript中存在两种变量：局部变量和全局变量。全局变量的生命周期会持续要页面卸载；而局部变量声明在函数中，它的生命周期从函数执行开始，直到函数执行结束，在这个过程中，局部变量会在堆或栈中存储它们的值，当函数执行结束后，这些局部变量不再被使用，它们所占有的空间就会被释放。
+ 不过，当局部变量被外部函数使用时，其中一种情况就是闭包，在函数执行结束后，函数外部的变量依然指向函数内部的局部变量，此时局部变量依然在被使用，所以不会回收。

## 8. JS垃圾回收的方式

标记清除，引用计数

**标记清除**

标记清除是浏览器常见的垃圾回收方式，当变量进入执行环境时，就标记这个变量“进入环境”，被标记为“进入环境”的变量是不能被回收的，因为他们正在被使用。当变量离开环境时，就会被标记为“离开环境”，被标记为“离开环境”的变量会被内存释放。
垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，因为环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。

**引用计数**

引用计数就是跟踪记录每个值被引用的次数。当声明了一个变量a并赋值引用类型b，b引用次数就是1。如果此时 a=c，那么b引用次数就减1变为0，说明这个变量已经没有价值，在垃圾回收期下次再运行时，这个变量就会被释放。引用计数会引起循环引用的问题：例如：obj1和obj2通过属性进行相互引用，两个对象的引用次数都是2

## 9. node 的内存管理跟垃圾回收机制有了解过吗？

首先分两种情况：V8 将内存分成 `新生代空间` 和 `老生代空间`

+ 新生代空间: 用于存活较短的对象
  + 又分成两个空间: from 空间 与 to 空间
  + Scavenge GC 算法: 当 from 空间被占满时，启动 GC 算法
    - 存活的对象从 from space 转移到 to space
    - 清空 from space
    - from space 与 to space 互换
    - 完成一次新生代 GC
+ 老生代空间: 用于存活时间较长的对象
  + 从 新生代空间 转移到 老生代空间 的条件（这个过程称为对象晋升）
    - 经历过一次以上 Scavenge GC 的对象
    - 当 to space 体积超过 25%
  + 标记清除算法：标记存活的对象，未被标记的则被释放
    - 增量标记：小模块标记，在代码执行间隙执，GC 会影响性能
    - 并发标记：不阻塞 js 执行