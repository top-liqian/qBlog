# 组件相关的面试题

## 1. 组件中data为什么是一个函数？

因为组件是用来复用但是JS里对象是引用关系，如果组件中 data 是一个对象，那么作用域没有隔离，子组件中的data属性值会相互影响，如果组件中data选项是一个函数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的data属性值不会互相影响；

> new Vue 实例里，data为什么是一个对象？
>
> new Vue的实例是不会被复用的，因此不存在引用对象的问题。

## 2. Vue 组件间通信有哪几种方式？

（1）父子组件间通信

1. 子组件通过 props 属性来接受父组件的数据，然后父组件在子组件上注册监听事件，子组件通过 emit 触发事件来向父组件发送数据。
2. 通过 ref 属性给子组件设置一个名字。父组件通过 $refs 组件名来获得子组件，子组件通过 $parent 获得父组件，这样也可以实现通信。
3. 使用 provide/inject，在父组件中通过 provide提供变量，在子组件中通过 inject 来将变量注入到组件中。不论子组件有多深，只要调用了 inject 那么就可以注入 provide中的数据。

（2）兄弟组件间通信

1. 使用 eventBus的方法（$emit / $on），它的本质是通过创建一个空的 Vue 实例来作为消息传递的对象，通信的组件引入这个实例，通信的组件通过在这个实例上监听和触发事件，来实现消息的传递。
2. 通过 $parent/$refs 来获取到兄弟组件，也可以进行通信。

（3）任意组件之间

1. 使用 eventBus ，其实就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。
2. 如果业务逻辑复杂，很多组件之间需要同时处理一些公共的数据，这个时候采用上面这一些方法可能不利于项目的维护。这个时候可以使用 vuex ，vuex 的思想就是将这一些公共的数据抽离出来，将它作为一个全局的变量来管理，然后其他组件就可以对这个公共数据进行读写操作，这样达到了解耦的目的。

## 3. vue组件会在什么时候下被销毁？

1. 当v-if为false的时候 
2. 父组件销毁的时候 
3. 调用this.$destory的时候
4. 页面关闭，路由跳转（没有使用keep-alive时的路由切换）

## 4. 如何保存页面的当前的状态

既然是要保持页面的状态（其实也就是组件的状态），那么会出现以下两种情况：前组件会被卸载和前组件不会被卸载

1. 前组件会被卸载: 
    + 将状态存储在`LocalStorage / SessionStorage`
        - 优点：兼容性好，不需要额外库或工具,简单快捷，基本可以满足大部分需求。
        - 缺点：状态通过 JSON 方法储存（相当于深拷贝），如果状态中有特殊情况（比如 Date 对象、Regexp 对象等）的时候会得到字符串而不是原来的值,如果 B 组件后退或者下一页跳转并不是前组件，那么 flag 判断会失效，导致从其他页面进入 A 组件页面时 A 组件会重新读取 Storage，会造成很奇怪的现象
    + 路由传值
        -  优点：简单快捷，不会污染 LocalStorage / SessionStorage;可以传递 Date、RegExp 等特殊对象（不用担心 JSON.stringify / parse 的不足）
        - 缺点：如果 A 组件可以跳转至多个组件，那么在每一个跳转组件内都要写相同的逻辑。
2. 组件不会被卸载
    + 单页面渲染: 要切换的组件作为子组件全屏渲染，父组件中正常储存页面状态。
        - 优点：代码量少,不需要考虑状态传递过程中的错误
        - 缺点：增加 A 组件维护成本,需要传入额外的 prop 到 B 组件,无法利用路由定位页面
    + keep-alive来缓存页面,当组件在keep-alive内被切换时组件的activated、deactivated这两个生命周期钩子函数会被执行 被包裹在keep-alive中的组件的状态将会被保留

## 5. 在vue.js中如何实现路由嵌套

路由嵌套会将其他组件渲染到该组件内，而不是使整个页面跳转到router-view定义组件渲染的位置，要进行页面跳转，要将页面渲染到根组件内。首先实例化根组件，在根组件中定义组件渲染容器，然后，挂载路由，当切换路由时，将会切换整个页面。

## 7. template和jsx的有什么分别？

template和jsx的都是render的一种表现形式，不同的是：JSX相对于template而言，具有更高的灵活性，在复杂的组件中，更具有优势，template 在代码结构上更符合视图与逻辑分离的习惯，更简单、更直观、更好维护

## 8. 组件渲染和更新过程

渲染组件时，会通过 vue.extend() 方法构建子组件的构造函数，并进行实例化。最终手动调用 $mount() 进行挂载。更新组件时会进行 patchVnode 流程，核心就是 diff 算法。

## 9. 为什么要使用异步组件？

节省打包出的结果，异步组件分开打包，采用jsonp的方式进行加载，有效解决文件过大的问题；核心就是包组件定义变成一个函数，依赖import语法，可以实现文件的分割加载。
