# 组件相关的面试题

## 组件中data为什么是一个函数？

JavaScript中的对象是引用类型的数据，当多个实例引用同一个对象时，只要一个实例对这个对象进行操作，其他实例中的数据也会发生变化。
而在Vue中，更多的是想要复用组件，那就需要每个组件都有自己的数据，这样组件之间才不会相互干扰。

所以组件的数据不能写成对象的形式，而是要写成函数的形式。数据以函数返回值的形式定义，这样当每次复用组件的时候，就会返回一个新的data，也就是说每个组件都有自己的私有数据空间，它们各自维护自己的数据，不会干扰其他组件的正常运行。

> 为什么组件中的 data 必须是一个函数，然后 return 一个对象，而 new Vue 实例里，data 可以直接是一个对象？

因为组件是用来复用的，且 JS 里对象是引用关系，如果组件中 data 是一个对象，那么这样作用域没有隔离，子组件中的 data 属性值会相互影响，如果组件中 data 选项是一个函数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的 data 属性值不会互相影响；而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题。

## Vue 组件间通信有哪几种方式？

Vue 组件间通信只要指以下 **3** 类通信：父子组件通信、隔代组件通信、兄弟组件通信

1. **props / $emit** : 适用父子组件通信
2. `ref / $refs`: 这种方式也是实现父子组件之间的通信, ref这个属性用在子组件上，它的引用就指向了子组件的实例，可以通过实例来访问组件的数据和方法。

3. `$parent / $children`适用 父子组件通信
   
   + 使用$parent可以让组件访问父组件的实例（访问的是上一级父组件的属性和方法）, 可以使用$root来访问根组件的实例
   + 使用$children可以让组件访问子组件的实例，但是是一个无序数组，$children并不能保证顺序，并且访问的数据也不是响应式的。  

4. `EventBus （$emit / $on）` 适用于 父子、隔代、兄弟组件通信

这种方法通过一个空的 Vue 实例作为中央事件总线（事件中心），用它来触发事件和监听事件，从而实现任何组件间的通信，包括父子、隔代、兄弟组件。

```js
// event-bus.js

import Vue from 'vue'
export const EventBus = new Vue()

// 发送事件

EventBus.$emit('add', { num: this.num++ })

// 监听事件
EventBus.$on('addition', param => {
    this.count = this.count + param.num;
})
```

5. `\$attrs/$listeners`: 适用于隔代组件通信

`\$attrs`：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 ( class 和 style 除外 )。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 ( class 和 style 除外 )，并且可以通过 v-bind="$attrs" 传入内部组件。通常配合 **inheritAttrs** 选项一起使用。

`\$listeners`：包含了父作用域中的 (不含 **.native** 修饰器的)  **v-on** 事件监听器。它可以通过 **v-on="$listeners"** 传入内部组件

6. `provide / inject` 适用于 隔代组件通信

祖先组件中通过 provider 来提供变量，然后在子孙组件中通过 inject 来注入变量。 provide / inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。依赖注入所提供的属性是非响应式的。

```js
provide() {  // 父组件
    return { num: this.num };
}
inject: ['num'] // 子组件
```

## 
## 7. Vuex 适用于 父子、隔代、兄弟组件通信

vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。

Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。
改变 store 中的状态的唯一途径就是显式地提交  (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。

总结：

（1）父子组件间通信

子组件通过 props 属性来接受父组件的数据，然后父组件在子组件上注册监听事件，子组件通过 emit 触发事件来向父组件发送数据。
通过 ref 属性给子组件设置一个名字。父组件通过 $refs 组件名来获得子组件，子组件通过 $parent 获得父组件，这样也可以实现通信。
使用 provide/inject，在父组件中通过 provide提供变量，在子组件中通过 inject 来将变量注入到组件中。不论子组件有多深，只要调用了 inject 那么就可以注入 provide中的数据。

（2）兄弟组件间通信

使用 eventBus 的方法，它的本质是通过创建一个空的 Vue 实例来作为消息传递的对象，通信的组件引入这个实例，通信的组件通过在这个实例上监听和触发事件，来实现消息的传递。
通过 $parent/$refs 来获取到兄弟组件，也可以进行通信。

（3）任意组件之间

使用 eventBus ，其实就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。

如果业务逻辑复杂，很多组件之间需要同时处理一些公共的数据，这个时候采用上面这一些方法可能不利于项目的维护。这个时候可以使用 vuex ，vuex 的思想就是将这一些公共的数据抽离出来，将它作为一个全局的变量来管理，然后其他组件就可以对这个公共数据进行读写操作，这样达到了解耦的目的。

## vue组件会在什么时候下被销毁？

1. 当v-if为false的时候 
2. 父组件销毁的时候 
3. 调用this.$destory的时候
4. 页面关闭，路由跳转（没有使用keep-alive时的路由切换）

##  如何保存页面的当前的状态

既然是要保持页面的状态（其实也就是组件的状态），那么会出现以下两种情况：前组件会被卸载和前组件不会被卸载

1. 前组件会被卸载: 
    + 将状态存储在`LocalStorage / SessionStorage`
        - 优点：兼容性好，不需要额外库或工具,简单快捷，基本可以满足大部分需求。
        - 缺点：状态通过 JSON 方法储存（相当于深拷贝），如果状态中有特殊情况（比如 Date 对象、Regexp 对象等）的时候会得到字符串而不是原来的值。（具体参考用 JSON 深拷贝的缺点）,如果 B 组件后退或者下一页跳转并不是前组件，那么 flag 判断会失效，导致从其他页面进入 A 组件页面时 A 组件会重新读取 Storage，会造成很奇怪的现象
    + 路由传值
        -  优点：简单快捷，不会污染 LocalStorage / SessionStorage;可以传递 Date、RegExp 等特殊对象（不用担心 JSON.stringify / parse 的不足）
        - 缺点：如果 A 组件可以跳转至多个组件，那么在每一个跳转组件内都要写相同的逻辑。
2. 组件不会被卸载
    + 单页面渲染: 要切换的组件作为子组件全屏渲染，父组件中正常储存页面状态。
        - 优点：代码量少,不需要考虑状态传递过程中的错误
        - 缺点：增加 A 组件维护成本,需要传入额外的 prop 到 B 组件,无法利用路由定位页面
    + keep-alive来缓存页面,当组件在keep-alive内被切换时组件的activated、deactivated这两个生命周期钩子函数会被执行 被包裹在keep-alive中的组件的状态将会被保留：

##  在vue.js中如何实现路由嵌套

路由嵌套会将其他组件渲染到该组件内，而不是使整个页面跳转到router-view定义组件渲染的位置，要进行页面跳转，要将页面渲染到根组件内。首先实例化根组件，在根组件中定义组件渲染容器，然后，挂载路由，当切换路由时，将会切换整个页面。

## 子组件可以直接改变父组件的数据吗？

子组件不可以直接改变父组件的数据。主要是为了维护父子组件的单向数据流。

Vue提倡单向数据流，即父级 props 的更新会流向子组件，但是反过来则不行。这是为了防止意外的改变父组件状态，使得应用的数据流变得难以理解，导致数据流混乱。如果破坏了单向数据流，当应用复杂时，debug 的成本会非常高。

只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。

##  template和jsx的有什么分别？

对于 runtime 来说，只需要保证组件存在 render 函数即可，而有了预编译之后，只需要保证构建过程中生成 render 函数就可以。在 webpack 中，使用vue-loader编译.vue文件，内部依赖的vue-template-compiler模块，在 webpack 构建过程中，将template预编译成 render 函数。与 react 类似，在添加了jsx的语法糖解析器babel-plugin-transform-vue-jsx之后，就可以直接手写render函数。

所以，template和jsx的都是render的一种表现形式，不同的是：JSX相对于template而言，具有更高的灵活性，在复杂的组件中，更具有优势，而 template 虽然显得有些呆滞。但是 template 在代码结构上更符合视图与逻辑分离的习惯，更简单、更直观、更好维护

## 组件渲染和更新过程

渲染组件时，会通过 vue.extend() 方法构建子组件的构造函数，并进行实例化。最终手动调用 $mount() 进行挂载。更新组件时会进行 patchVnode 流程，核心就是 diff 算法。

## 为什么要使用异步组件？

节省打包出的结果，异步组件分开打包，采用jsonp的方式进行加载，有效解决文件过大的问题；核心就是包组件定义变成一个函数，依赖import语法，可以实现文件的分割加载。

