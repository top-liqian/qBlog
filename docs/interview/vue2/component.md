# 组件相关的面试题

## 一、组件中 data 为什么是一个函数？

JavaScript中的对象是引用类型的数据，当多个实例引用同一个对象时，只要一个实例对这个对象进行操作，其他实例中的数据也会发生变化。
而在Vue中，更多的是想要复用组件，那就需要每个组件都有自己的数据，这样组件之间才不会相互干扰。

所以组件的数据不能写成对象的形式，而是要写成函数的形式。数据以函数返回值的形式定义，这样当每次复用组件的时候，就会返回一个新的data，也就是说每个组件都有自己的私有数据空间，它们各自维护自己的数据，不会干扰其他组件的正常运行。

> 为什么组件中的 data 必须是一个函数，然后 return 一个对象，而 new Vue 实例里，data 可以直接是一个对象？

因为组件是用来复用的，且 JS 里对象是引用关系，如果组件中 data 是一个对象，那么这样作用域没有隔离，子组件中的 data 属性值会相互影响，如果组件中 data 选项是一个函数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的 data 属性值不会互相影响；而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题。

## 三、Vue 组件间通信有哪几种方式？

Vue 组件间通信只要指以下 **3** 类通信：父子组件通信、隔代组件通信、兄弟组件通信

1. **props / $emit** 适用 父子组件通信

2. **ref** 与 **$parent / $children** 适用 父子组件通

**ref**：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例

**$parent / $children**：访问父 / 子实例

3. **EventBus （$emit / $on）** 适用于 父子、隔代、兄弟组件通信

这种方法通过一个空的 Vue 实例作为中央事件总线（事件中心），用它来触发事件和监听事件，从而实现任何组件间的通信，包括父子、隔代、兄弟组件。

4. **\$attrs/$listeners** 适用于 隔代组件通信

**\$attrs**：包含了父作用域中不被 **prop** 所识别 (且获取) 的特性绑定 ( class 和 style 除外 )。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 ( class 和 style 除外 )，并且可以通过 v-bind="$attrs" 传入内部组件。通常配合 **inheritAttrs** 选项一起使用。

**\$listeners**：包含了父作用域中的 (不含 **.native** 修饰器的)  **v-on** 事件监听器。它可以通过 **v-on="$listeners"** 传入内部组件

5. provide / inject 适用于 隔代组件通信

祖先组件中通过 provider 来提供变量，然后在子孙组件中通过 inject 来注入变量。 provide / inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。

6. Vuex 适用于 父子、隔代、兄弟组件通信

vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。

Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。
改变 store 中的状态的唯一途径就是显式地提交  (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。

## 四、vue组件会在什么时候下被销毁？

1. 当v-if为false的时候 
2. 父组件销毁的时候 
3. 调用this.$destory的时候
4. 页面关闭，路由跳转（没有使用keep-alive时的路由切换）

##  如何保存页面的当前的状态

既然是要保持页面的状态（其实也就是组件的状态），那么会出现以下两种情况：前组件会被卸载和前组件不会被卸载

1. 前组件会被卸载: 
    + 将状态存储在`LocalStorage / SessionStorage`
        - 优点：兼容性好，不需要额外库或工具,简单快捷，基本可以满足大部分需求。
        - 缺点：状态通过 JSON 方法储存（相当于深拷贝），如果状态中有特殊情况（比如 Date 对象、Regexp 对象等）的时候会得到字符串而不是原来的值。（具体参考用 JSON 深拷贝的缺点）,如果 B 组件后退或者下一页跳转并不是前组件，那么 flag 判断会失效，导致从其他页面进入 A 组件页面时 A 组件会重新读取 Storage，会造成很奇怪的现象
    + 路由传值
        -  优点：简单快捷，不会污染 LocalStorage / SessionStorage;可以传递 Date、RegExp 等特殊对象（不用担心 JSON.stringify / parse 的不足）
        - 缺点：如果 A 组件可以跳转至多个组件，那么在每一个跳转组件内都要写相同的逻辑。
2. 组件不会被卸载
    + 单页面渲染: 要切换的组件作为子组件全屏渲染，父组件中正常储存页面状态。
        - 优点：代码量少,不需要考虑状态传递过程中的错误
        - 缺点：增加 A 组件维护成本,需要传入额外的 prop 到 B 组件,无法利用路由定位页面
    + keep-alive来缓存页面,当组件在keep-alive内被切换时组件的activated、deactivated这两个生命周期钩子函数会被执行 被包裹在keep-alive中的组件的状态将会被保留：

##  在vue.js中如何实现路由嵌套

路由嵌套会将其他组件渲染到该组件内，而不是使整个页面跳转到router-view定义组件渲染的位置，要进行页面跳转，要将页面渲染到根组件内。首先实例化根组件，在根组件中定义组件渲染容器，然后，挂载路由，当切换路由时，将会切换整个页面。

