# 技术面试题

## 1. ES5有几种继承的方式

1. 原型链继承(new)
2. 借用构造函数继承(call/apply即执行构造函数并且改变this的指向问题)
3. 组合继承(call/apply + new)
4. 原型式继承(Object.create())
5. 寄生继承
6. 寄生组合式继承


## 1.1 ES5/ES6 的继承除了写法以外还有什么区别？

> 1. ES5的继承机制实际上先创建子类实例对象，然后在将父类的属性和方法绑定在子类上，通过apply/call的方式；（ES5先创建子类，在实例化父类并添加到子类this中）但是ES6的继承机制是先创建父类的实例对象this（即先调用super方法），然后再用子类的构造函数修改this（ES6先创建父类，在实例化子集中通过调用super方法访问父级后，在通过修改this实现继承）。
> 2. ES5的继承时通过原型或构造函数机制来实现；.ES6通过class关键字定义类，类之间通过extends关键字实现继承，里面有构造方法constructor，子类必须在constructor方法中调用super方法，否则新建实例报错。因为子类没有自己的this对象，而是继承了父类的this对象，然后对其进行加工。如果不调用super方法，子类得不到this对象。


## 2. vue的构造函数为什么没有使用class语法糖

vue构造函数的方法很多，如果使用class进行维护会篇幅很大，对于重写方法的行为也不是很友好，所以还是采用了构造函数的方式，在其原型上增加方法进行拓展

## 3. $set()的本质是什么？

通过调用重写的数组splice方法实现的

## 4. Vue中模板编译原理？

vue中的模板template无法被浏览器解析并渲染，因为不是正确的HTML语法，所有需要将template转化成一个JavaScript函数，这样浏览器就可以执行这一个函数并渲染出对应的HTML元素，就可以让视图跑起来了，这个过程叫做模板编译。模板编译又分三个阶段，解析parse，优化optimize，生成generate，最终生成可执行函数render。

+ parse阶段：使用大量的正则表达式对template字符串进行解析，将标签、指令、属性等转化为抽象语法树AST。

+ optimize阶段：遍历AST，找到其中的一些静态节点并进行标记，方便在页面重渲染的时候进行diff比较时，直接跳过这一些静态节点，优化runtime的性能。

+ generate阶段：将最终的AST转化为render函数字符串。

## 5. Vue template 到 render 的过程

vue的模版编译过程主要如下：template -> ast -> render函数，vue 在模版编译版本的码中会执行 compileToFunctions 将template转化为render函数

CompileToFunctions中的主要逻辑如下∶ 
1. 调用parse方法将template转化为ast（抽象语法树）
   + parse的目标：把tamplate转换为AST树，它是一种用 JavaScript对象的形式来描述整个模板。
   + 解析过程：利用正则表达式顺序解析模板，当解析到开始标签、闭合标签、文本的时候都会分别执行对应的 回调函数，来达到构造AST树的目的。
   + AST元素节点总共三种类型：type为1表示普通元素、2为表达式、3为纯文本
2. 对静态节点做优化：这个过程主要分析出哪些是静态节点，给其打一个标记，为后续更新渲染可以直接跳过静态节点做优化，深度遍历AST，查看每个子树的节点元素是否为静态节点或者静态节点根。如果为静态节点，他们生成的DOM永远不会改变，这对运行时模板更新起到了极大的优化作用。
3. generate将ast抽象语法树编译成 render字符串并将静态部分放到 staticRenderFns 中，最后通过 new Function(`` render``) 生成render函数

## 6. 介绍一下vue的diff算法？

在新老虚拟dom对比时

+ 首先，对比节点本身，判断是否为同一节点，如果不为同一节点，则删除该节点重新创建节点进行替换
+ 如果为相同节点，进行patchVnode，判断如何对该节点的子节点进行处理，先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除)
+ 比较如果都有子节点，则进行updateChildren，判断如何对这些新老节点的子节点进行操作（diff核心）。
+ 匹配时，找到相同的子节点，递归比较子节点

在diff中，只对同层的子节点进行比较，放弃跨级的节点比较，使得时间复杂从O(n^3)降低值O(n)，也就是说，只有当新旧children都为多个子节点时才需要用核心的Diff算法进行同层级比较。****

## 7. Vue3 Diff算法和 Vue2 的区别

我们知道在数据变更触发页面重新渲染，会生成虚拟 DOM 并进行 patch 过程，这一过程在 Vue3 中的优化有如下
+ 编译阶段的优化：
  - 事件缓存：将事件缓存(如: @click)，可以理解为变成静态的了
  - 静态提升：第一次创建静态节点时保存，后续直接复用
  - 添加静态标记：给节点添加静态标记，以优化 Diff 过程
  由于编译阶段的优化，除了能更快的生成虚拟 DOM 以外，还使得 Diff 时可以跳过"永远不会变化的节点"，
+ Diff 优化如下
  - Vue2 是全量 Diff，Vue3 是静态标记 + 非全量 Diff
  - 使用最长递增子序列优化了对比流程
目前公布的数据就是 Vue3 update 性能提升了 1.3~2 倍

## 8. vue2 keep-alive的实现原理

keep-alive 具体是通过 cache 数组缓存所有组件的 vnode 实例。当 cache 内原有组件被使用时会将该组件 key 从 keys 数组中删除，然后 push 到 keys数组最后，以便清除最不常用组件。

keep-alive的实现步骤：

1. 获取 keep-alive 下第一个子组件的实例对象，通过他去获取这个组件的组件名
2. 通过当前组件名去匹配原来 include 和 exclude，判断当前组件是否需要缓存，不需要缓存，直接返回当前组件的实例vNode
3. 需要缓存，判断他当前是否在缓存数组里面：
   + 存在，则将他原来位置上的 key 给移除，同时将这个组件的 key 放到数组最后面（LRU）；
   + 不存在，将组件 key 放入数组，然后判断当前 key数组是否超过 max 所设置的范围，超过，那么削减未使用时间最长的一个组件的 key
4. 最后将这个组件的 keepAlive 设置为 true

## 9. 哪些情况会导致内存泄漏？

1. 全局变量。在局部作用域中，函数执行完毕后，变量就没有存在的必要了，垃圾回收机制很快的做出判断并回收；但是对于全局变量，很难判断什么时候不用这些变量，无法正常回收。
解决办法：
① 尽量少使用全局变量；
② 使用严格模式，在 js 文件头部或者函数的顶部加上use strict。

2. 闭包引起的内存泄露。闭包可以读取函数内部的变量，然后让这些变量始终保存在内存中，如果在使用结束后没有将局部变量清除，就可能导致内存泄露。
解决办法：将事件处理函数定义在外部，解除闭包。

3. 定时器setInterval或者setTimeout不再需要使用时，且没有被清除，导致定时器的回调函数及其内部依赖的变量都不能被回收，就会造成内存泄漏。
解决办法：当不需要定时器的时候，调用clearInterval或者clearTimeout手动清除。

4. 事件监听。垃圾回收机制不好判断事件是否需要被解除，导致callback不能被释放，此时需要手动解除绑定。
解决办法：及时使用removeEventListener移除事件监听。

5. 元素引用没有清理。
解决办法：移除元素后，手动设置元素的引用为null。

6. console。传递给console.log的对象是不能被垃圾回收，可能会存在内存泄漏。
解决办法：清除不必要的console。

 

# 项目相关面试题

## 1. 可以简单的介绍一下你们公司目前的架构吗？

## 1.1 你们有自己的前端脚手架吗？脚手架都做了哪些事情？

## 1.2 能简单介绍一下微前端架构吗？ web component 和 qiankun 的主要区别是什么？

## 2. 如果现在有一个机会让你对你的项目进行微前端重构，你觉得应该从哪几个方面入手

## 3. axios的二次封装都做了哪些事可以介绍一下吗？

## 4. 对项目的体积优化都做了哪些事情？

## 5. 如何减少大屏的白屏时间的？

## 6. 10余个hooks函数都是封装了些什么？ 引用方式是什么样？在项目工程内部，还是封装了具体的hook库

# 算法题目

斐波那契数列


# 个人素质面试题

1. 你觉得前端价值是什么？

2. 平时都是怎么样了解最新技术的开拓视野的
   

