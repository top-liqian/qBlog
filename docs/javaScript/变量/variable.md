# 深入理解javascript的变量

## 一、数据类型的种类一共有8种,8种变量又分为原始类型和对象类型

原始类型 - 栈内存（被引用或拷贝时，会创建一个完全相等的变量）

+ number：包含所有可能的数字类型，+Infinity, -Infinity, NAN等
+ string：包含所有有限的字符集合，一串表示文本值的字符序列
+ boolean：有两个值（true， false）
+ Null：只包含一个值null, 表示空对象指针
+ Undefined：只有自己一个值undefined
+ Symbol(ES2016)：用来表示唯一的对象的键值，一种实例是唯一且不可改变的数据类型
+ bigInt(ES2010)：如今已经被chrome支持
  
对象复杂类型 - 堆内存（存储的是地址，多个引用指向同一个地址，这里会涉及一个“共享”的概念。）

+ Object: 从逻辑上来讲，对象是属性的结合，并且每个属性要么是数据属性，要么就是迭代器访问属性

引用数据类型（Object）又分为如下这几种常见的类型：

+ Array - 数组对象
+ RegExp - 正则对象
+ Date - 日期对象
+ Math - 数学函数
+ Function - 函数对象
  
## 二、为什么区分原始类型和对象类型

### 2.1 不可变性

上面提到的原始类型，在es标准中，他们被定义为```primitive values```,即原始值，代表本身是不可被改变的

以字符串为例，我们在调用操作字符串的方法时，是没有任何方法可以直接改变字符串的，这些方法都是在原字符串的基础之上```重新产生了一个字符串```，这就印证了```不可被改变性```

但是我们通常可以看到以下的代码

```js
  var str = 1
  str += 2
  console.log(str)
```

我们就发现字符串str被改变了，但是并没有改变```不可被改变性```,我们从内存的角度上来理解：

在js当中，每一个变量在内存中都需要一个空间来存储

内存中又分为栈内存和堆内存

栈内存：

+ 存储的值大小固定
+ 空间较小
+ 可以直接操作其保存的变量，运行效率高
+ 由系统自动分配存储空间

js的原始类型的值被直接存储在栈中，在变量定义时，栈就为其分配好了内存空间

![变量-1](http://localhost:3000/public/变量-1.png)

由于栈大大小是固定的，那么就注定了存在栈中的变量是不可变的了

在上面的代码中，我们执行了```str += 2```， 实际上是我们又重新开辟了一块内存空间用来存储```3```, 然后我们再把变量```str```指向这个空间，所以不违背```不可变性的```特点

![变量-2](http://localhost:3000/public/变量-2.png)

### 2.2 引用类型

堆内存：

+ 通过代码进行分配空间
+ 存储值大小不一定，可以动态调整
+ 无法直接操作其内部存储，使用引用地址读取
+ 空间较大，运行效率低

相对于上面具有不可变性的原始类型，我习惯把对象称为引用类型，引用类型的值实际存储在堆内存中，它在栈中只存储了一个固定长度的地址，这个地址指向堆内存中的值。

```js
  var obj1 = { name:"ConardLi" }
  var obj2 = { age:18 }
  var obj3 = function(){ ... }
  var obj4 = [1,2,3,4,5,6,7,8,9]
```

![变量-3](http://localhost:3000/public/变量-3.png)

当然，引用类型就不再具有```不可变性```了，我们可以轻易的改变它们：

```js
  obj1.name = "ConardLi6";
  obj2.age = 19;
  obj4.length = 0;
  console.log(obj1); //{name:"ConardLi6"}
  console.log(obj2); // {age:19}
  console.log(obj4); // []
```

以数组为例，它的很多方法都可以改变它自身

+ ```pop```删除数组最后一个元素，数组为空，则不改变数组，返回undefined，相反改变原数组，返回被删除元素
+ ```push```向数组末尾添加一个或者多个元素，改变原数组，返回新数组的长度
+ ```shift```删除数组第一个元素，数组为空，则不改变数组，返回undefined，相反改变原数组，返回被删除元素
+ ```unshift```向数组开头添加一个或者多个元素，改变原数组，返回新数组的长度
+ ```reverse```颠倒数组的顺序，改变原数组，返回该数组
+ ```sort```对数组元素进行排序，改变原数组，返回该数组
+ ```splice```从数组中添加/删除项目，改变原数组，返回该被删除的数组

下面我们通过几个操作来对比一下原始类型和引用类型的区别：

### 2.3 复制

当我们把一个变量的值复制到另一个变量上时，原始类型和引用类型的表现是不一样的，先来看看原始类型：

```js
  var name = 'ConardLi';
  var name2 = name;
  name2 = 'code秘密花园';
  console.log(name); // ConardLi;
```

![变量-4](http://localhost:3000/public/变量-4.png)

复制一个引用类型：

```js
  var obj = {name:'ConardLi'};
  var obj2 = obj;
  obj2.name = 'code秘密花园';
  console.log(obj.name); // code秘密花园
```

![变量-5](http://localhost:3000/public/变量-5.png)

当我们复制引用类型的变量时，实际上复制的是栈中存储的地址，所以复制出来的```obj2```实际上和```obj```指向的堆中同一个对象。因此，我们改变其中任何一个变量的值，另一个变量都会受到影响，这就是为什么会有深拷贝和浅拷贝的原因。

### 2.4 比较

当我们在对两个变量进行比较时，不同类型的变量的表现是不同的：

对于原始类型，比较时会直接比较它们的值，如果值相等，即返回true。

对于引用类型，比较时会比较它们的引用地址，虽然两个变量在堆中存储的对象具有的属性值都是相等的，但是它们被存储在了不同的存储空间，因此比较值为false。

![变量-6](http://localhost:3000/public/变量-6.png)

### 2.5 值传递和引用传递

1. ```ECMAScript```中所有的函数的参数都是按值传递的。
2. 当函数参数是引用类型时，我们同样将参数复制了一个副本到局部变量，只不过复制的这个副本是指向堆内存中的地址而已，我们在函数内部对对象的属性进行操作，实际上和外部变量指向堆内存中的值相同，但是这并不代表着引用传递

> 函数参数传递的并不是变量的引用，而是变量拷贝的副本，当变量是原始类型时，这个副本就是值本身，当变量是引用类型时，这个副本是指向堆内存的地址。

#### 三、分不清的null和undefined

##### 3.1 null

表示被赋值过的对象，刻意把一个对象赋值为null，故意表示其为空，不应有值。

所以对象的某个属性值为null是正常的，null转换为数值时值为0

##### 3.2 undefined

表示“缺少值”，即此处应有一个值，但还没有定义，

undefined转为数值时为NaN(非数字值的特殊值)

#### 四、Symbol

> 每个从Symbol()返回的symbol值都是唯一的。一个symbol值能作为对象属性的标识符；这是该数据类型仅有的目的。

##### 4.1 Symbol特性

1. 独一无二

  直接使用Symbol()创建新的symbol变量，可选用一个字符串用于描述。当参数为对象时，将调用对象的toString()方法。

  ```js
     var sym1 = Symbol() // Symbol()
     var sym2 = Symbol('liqian') // Symbol('liqian')
     var sym3 = Symbol({ name: 'liqian' }) // Symbol([object Object])
  ```

  如果我们想创造两个相等的```Symbol变量```，可以使用```Symbol.for(key)```

  > 使用给定的key搜索现有的symbol，如果找到则返回该symbol。否则将使用给定的key在全局symbol注册表中创建一个新的symbol。

  ```js
    var sym1 = Symbol.for('ConardLi');
    var sym2 = Symbol.for('ConardLi');
    console.log(sym1 === sym2); // true
  ```

2. 原始类型

  注意是使用Symbol()函数创建symbol变量，并非使用构造函数，使用new操作符会直接报错。

  ```js
    typeof Symbol() === 'symbol'
    typeof Symbol('ConardLi') === 'symbol'
  ```

3. 不可枚举

  当使用Symbol作为对象属性时，可以保证对象不会出现重名属性，调用for...in不能将其枚举出来，另外调用Object.getOwnPropertyNames、Object.keys()也不能获取Symbol属性。

  > 可以调用Object.getOwnPropertySymbols()用于专门获取Symbol属性。

4. 应用场景

+ 应用一：防止XSS
+ 应用二：私有属性：借助Symbol类型的不可枚举，我们可以在类中模拟私有属性，控制变量读写
+ 应用三：防止属性污染：在某些情况下，我们可能要为对象添加一个属性，此时就有可能造成属性覆盖，用Symbol作为对象属性可以保证永远不会出现同名属性

#### 五、Number（未完）

为什么会出现0.1 + 0.2 ！== 0.3

##### 5.1 精度丢失

计算机中所有的数据都是以```二进制```存储的，所以在计算时计算机要把数据先转换成```二进制```进行计算，然后在把计算结果转换成```十进制```。

在计算0.1+0.2时，```二进制```计算发生了```精度丢失```，导致再转换成```十进制```后和预计的结果不符。

##### 5.2 js对二进制小数的存储方式

ECMAScript中的Number类型遵循```IEEE 754标准```。使用```64位```固定长度来表示。

##### 5.3 IEEE 754标准

IEEE 754标准标准包含一组实数的二进制表示法，它有三部分组成

+ 符号位
+ 指数位
+ 尾数位

![变量](http://localhost:3000/public/变量-7.png)

JavaScript使用的是64位双精度浮点数编码，所以它的```符号位```占```1```位，指数位占```11```位，尾数位占```52```位。

下面我们在理解下什么是符号位、指数位、尾数位，以0.1为例：

它的二进制为：```0.0001100110011001100...```

为了节省存储空间，在计算机中它是以科学计数法表示的，也就是

1.100110011001100... X 2负四次方

如果这里不好理解可以想一下十进制的数：

1100的科学计数法为11 X 10平方

#### 六、引用类型

> 在ECMAScript中，引用类型是一种数据结构，用于将数据和功能组织在一起。

我们通常所说的对象，就是某个特定引用类型的实例

在ECMAScript关于类型的定义中，只给出了Object类型，实际上，我们平时使用的很多引用类型的变量，并不是由Object构造的，但是它们原型链的终点都是Object，这些类型都属于引用类型。

+ Array 数组
+ Date 日期
+ RegExp 正则
+ Function 函数

##### 6.1包装类型

> 特殊点：除了以上的数据类型之外要引入一个叫做 ```基本包装类型``` 的概念, 除了 ```Object Array``` 等引用类型外，其实还有三种特殊的引用类型 ```String、 Number、 Boolean```方便我们操作与其对应的基本类型，而它们就是基本包装类型。
> 引用类型与基本包装类型最大的区别在于```对象的生存期```,使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中，而定义的基本类型则存在与一行代码的执行瞬间，然后立刻就会被销毁，这就意味这我们不能再运行中时为基本类型添加属性与方法

str 作为一个基本类型是没有 length 属性的，但是它的基本包装类型 String 有，其实在执行 console.log(str.length) 这段代码时，事情的经过是这样的：

1. 创建String类型的一个实例
2. 在实例上调用指定的方法
3. 销毁这个实例

所以获取字符串变量 str 的长度的代码，内部实现大概是这个样子的：

```js
   var str = 'hello'
   var len = str.length
   console.log('length:', len) // 5

   var str = 'hello'
   var _str = new String('hello')
   var len = _str.length
   _str = null
   console.log('length:', len) // 5
```

> 面试题：给出下面题目的正确答案（相同面试题为：我们都知道字符串是基本数据类型,基本类型是没有方法的，但为什么字符串还有很多方法？）

```js
  var str = 'string';
  str.pro = 'hello';
  console.log(str.pro + 'world');
  // undefindedworld 原因是：基本包装类型创建的实例上面定义的pro属性在定义后就会立刻销毁，当执行 str.pro = 'hello' 时，实际上内部创建了一个基本包装类型的实例，然后给这个实例的 pro 属性赋值为 hello，实例创建后马上销毁了，当下一次试图获取 str.pro 的值时，又会创建一个基本包装类型的实例，显然新创建的实例时没有 pro 属性的，为 undefined，所以最后输出 undefinedworld
```

6.2  装箱和拆箱

+ 装箱转换：把基本类型转换为对应的包装类型
  
+ 拆箱操作：把引用类型转换为基本类型
